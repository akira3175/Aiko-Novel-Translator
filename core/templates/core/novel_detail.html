{% extends 'core/base.html' %}

{% load custom_filters %}

{% block title %}{{ novel.title }} - Novel Translator{% endblock %}

{% block extra_css %}
<style>
    .breadcrumb {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 1.5rem;
        color: var(--text-light);
        font-size: 0.9rem;
    }
    
    .breadcrumb a {
        color: var(--primary);
        text-decoration: none;
    }
    
    .novel-header {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1));
        border-radius: 12px;
        padding: 2rem;
        margin-bottom: 2rem;
        border: 2px solid var(--primary);
    }
    
    .novel-title {
        font-size: 2rem;
        font-weight: 700;
        color: var(--dark);
        margin-bottom: 0.75rem;
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }
    
    .novel-author {
        font-size: 1.1rem;
        color: var(--text-light);
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 1rem;
    }
    
    .novel-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 1.5rem;
        margin-top: 1.5rem;
    }
    
    .stat-item {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
    }
    
    .stat-label {
        font-size: 0.85rem;
        color: var(--text-light);
        font-weight: 500;
    }
    
    .stat-value {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--primary);
    }
    
    .tabs {
        display: flex;
        gap: 0.5rem;
        border-bottom: 2px solid var(--border);
        margin-bottom: 2rem;
    }
    
    .tab {
        padding: 1rem 1.5rem;
        border: none;
        background: none;
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-light);
        cursor: pointer;
        border-bottom: 3px solid transparent;
        transition: all 0.2s;
        text-decoration: none;
    }
    
    .tab:hover {
        color: var(--primary);
    }
    
    .tab.active {
        color: var(--primary);
        border-bottom-color: var(--primary);
    }
    
    .tab-content {
        display: none;
    }
    
    .tab-content.active {
        display: block;
    }
    
    .volumes-section {
        margin-top: 2rem;
    }
    
    .section-title {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--dark);
        margin-bottom: 1.5rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .volume-card {
        background: white;
        border: 2px solid var(--border);
        border-radius: 12px;
        padding: 1.5rem;
        margin-bottom: 1rem;
        transition: all 0.3s;
        cursor: pointer;
    }
    
    .volume-card:hover {
        border-color: var(--primary);
        box-shadow: 0 4px 12px rgba(99, 102, 241, 0.15);
        transform: translateX(8px);
    }
    
    .volume-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .volume-info {
        display: flex;
        align-items: center;
        gap: 1rem;
    }
    
    .volume-number {
        width: 60px;
        height: 60px;
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        color: white;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        font-weight: 700;
    }
    
    .volume-details h3 {
        font-size: 1.25rem;
        color: var(--dark);
        margin-bottom: 0.25rem;
    }
    
    .volume-subtitle {
        color: var(--text-light);
        font-size: 0.9rem;
    }
    
    .volume-meta {
        text-align: right;
    }
    
    .chapter-count {
        font-size: 1.25rem;
        font-weight: 700;
        color: var(--primary);
    }
    
    /* Glossary Section */
    .glossary-controls {
        display: flex;
        gap: 1rem;
        margin-bottom: 1.5rem;
        flex-wrap: wrap;
    }
    
    .glossary-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1rem;
        margin-bottom: 2rem;
    }
    
    .glossary-card {
        background: white;
        border: 2px solid var(--border);
        border-radius: 12px;
        padding: 1.5rem;
        text-align: center;
    }
    
    .glossary-table {
        background: white;
        border: 2px solid var(--border);
        border-radius: 12px;
        overflow: hidden;
        margin-top: 1rem;
    }
    
    table {
        width: 100%;
        border-collapse: collapse;
    }
    
    thead {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1));
    }
    
    th {
        padding: 1rem;
        text-align: left;
        font-weight: 700;
        color: var(--dark);
        border-bottom: 2px solid var(--border);
    }
    
    td {
        padding: 1rem;
        border-bottom: 1px solid var(--light);
    }
    
    tbody tr:hover {
        background: var(--light);
    }
    
    .editable-cell {
        cursor: pointer;
        position: relative;
    }
    
    .editable-cell:hover {
        background: rgba(99, 102, 241, 0.05);
    }
    
    .edit-input {
        width: 100%;
        padding: 0.5rem;
        border: 2px solid var(--primary);
        border-radius: 4px;
        font-size: 0.95rem;
    }
    
    /* Review Section */
    .review-controls {
        display: flex;
        gap: 1rem;
        margin-bottom: 2rem;
        flex-wrap: wrap;
    }
    
    .review-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1rem;
        margin-bottom: 2rem;
    }
    
    .review-card {
        background: white;
        border: 2px solid var(--border);
        border-radius: 12px;
        padding: 1.5rem;
    }
    
    .chapter-review-item {
        background: white;
        border: 2px solid var(--border);
        border-radius: 12px;
        padding: 1.5rem;
        margin-bottom: 1rem;
    }
    
    .review-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        padding-bottom: 1rem;
        border-bottom: 2px solid var(--light);
    }
    
    .score-badge {
        padding: 0.5rem 1rem;
        border-radius: 20px;
        font-weight: 700;
        font-size: 1rem;
    }
    
    .score-high {
        background: #d1fae5;
        color: #065f46;
    }
    
    .score-medium {
        background: #fef3c7;
        color: #92400e;
    }
    
    .score-low {
        background: #fee2e2;
        color: #991b1b;
    }
    
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 9999;
    }
    
    .loading-overlay.show {
        display: flex;
    }
    
    .loading-content {
        background: white;
        padding: 2rem;
        border-radius: 12px;
        text-align: center;
        min-width: 300px;
    }
    
    .loading-spinner {
        width: 50px;
        height: 50px;
        border: 5px solid var(--light);
        border-top: 5px solid var(--primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 1rem;
    }
    
    .progress-bar {
        width: 100%;
        height: 8px;
        background: var(--light);
        border-radius: 4px;
        overflow: hidden;
        margin-top: 1rem;
    }
    
    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--primary), var(--secondary));
        transition: width 0.3s;
    }
</style>
{% endblock %}

{% block content %}
<div class="breadcrumb">
    <a href="/">Dashboard</a>
    <span>/</span>
    <span>{{ novel.title }}</span>
</div>

<div class="novel-header">
    <h1 class="novel-title">
        <span>üìñ</span>
        {{ novel.title }}
    </h1>
    <div class="novel-author">
        <span>‚úçÔ∏è</span>
        {{ novel.author|default:"Unknown Author" }}
    </div>
    {% if novel.description %}
    <p style="color: var(--text); line-height: 1.6; margin-top: 1rem;">
        {{ novel.description|striptags }}
    </p>
    {% endif %}
    <div class="novel-stats">
        <div class="stat-item">
            <span class="stat-label">Volumes</span>
            <span class="stat-value">{{ novel.volumes.count }}</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Chapters</span>
            <span class="stat-value" id="totalChapters">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Glossary</span>
            <span class="stat-value">{{ glossary_count }}</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Language</span>
            <span class="stat-value">{{ novel.language|upper }}</span>
        </div>
    </div>
    <div style="margin-top: 1.5rem;">
        <a href="{% url 'core:export_novel_yaml' novel.id %}" class="btn btn-secondary">
            üì• Export YAML
        </a>
    </div>
</div>

<div class="tabs">
    <button class="tab active" onclick="switchTab('volumes')">üìö Volumes</button>
    <a class="tab" href="{% url 'core:glossary_list' novel.id %}">üìñ Glossary</a>
    <button class="tab" onclick="switchTab('review')">üîç Review</button>
</div>

<!-- Volumes Tab -->
<div class="tab-content active" id="volumes-tab">
    <div class="volumes-section">
        {% if novel.volumes.all %}
            {% for volume in novel.volumes.all %}
            <a href="{% url 'core:volume_detail' volume.id %}" style="text-decoration: none;">
                <div class="volume-card">
                    <div class="volume-header">
                        <div class="volume-info">
                            <div class="volume-number">{{ volume.index }}</div>
                            <div class="volume-details">
                                <h3>Volume {{ volume.index }}</h3>
                                <div class="volume-subtitle">{{ volume.title|default:"Untitled" }}</div>
                            </div>
                        </div>
                        <div class="volume-meta">
                            <div class="chapter-count">{{ volume.chapters.count }}</div>
                            <div style="color: var(--text-light); font-size: 0.85rem;">chapters</div>
                        </div>
                    </div>
                </div>
            </a>
            {% endfor %}
        {% else %}
            <div style="text-align: center; padding: 3rem; background: var(--light); border-radius: 12px;">
                <div style="font-size: 3rem; margin-bottom: 1rem;">üìö</div>
                <div style="color: var(--text-light);">Ch∆∞a c√≥ volume n√†o</div>
            </div>
        {% endif %}
    </div>
</div>

<!-- Glossary Tab -->
<div class="tab-content" id="glossary-tab">
    <div class="glossary-controls">
        <button onclick="generateGlossary()" class="btn btn-success" id="generateGlossaryBtn">
            ü§ñ T·∫°o T·ª± ƒê·ªông
        </button>
        <button onclick="showAddGlossaryModal()" class="btn btn-primary">
            ‚ûï Th√™m Term
        </button>
        <button onclick="resetCheckpoint()" class="btn btn-warning">
            üîÑ Reset Checkpoint
        </button>
        <input 
            type="text" 
            placeholder="üîç T√¨m ki·∫øm..." 
            style="flex: 1; min-width: 250px; padding: 0.75rem; border: 2px solid var(--border); border-radius: 8px;"
            onkeyup="searchGlossary(this.value)"
        >
    </div>
    
    <div class="glossary-stats">
        <div class="glossary-card">
            <div class="stat-label">T·ªïng terms</div>
            <div class="stat-value" id="glossaryTotal">{{ glossary_count }}</div>
        </div>
        <div class="glossary-card">
            <div class="stat-label">Checkpoint</div>
            <div class="stat-value" id="glossaryCheckpoint">{{ checkpoint }}</div>
        </div>
        <div class="glossary-card">
            <div class="stat-label">T·ª´ ƒë√£ x·ª≠ l√Ω</div>
            <div class="stat-value">~{{ checkpoint|multiply:3000|default:0 }}</div>
        </div>
    </div>
    
    <div class="glossary-table">
        <table>
            <thead>
                <tr>
                    <th style="width: 30%;">Ti·∫øng Trung</th>
                    <th style="width: 30%;">Ti·∫øng Vi·ªát</th>
                    <th style="width: 30%;">Ghi ch√∫</th>
                    <th style="width: 10%;">Thao t√°c</th>
                </tr>
            </thead>
            <tbody id="glossaryTableBody">
                <!-- Glossary items loaded via AJAX -->
            </tbody>
        </table>
    </div>
    
    <div class="pagination" id="glossaryPagination" style="margin-top: 2rem;">
        <!-- Pagination loaded via AJAX -->
    </div>
</div>

<!-- Review Tab -->
<div class="tab-content" id="review-tab">
    <div class="review-controls">
        <button onclick="reviewAllChapters()" class="btn btn-warning" id="reviewAllBtn">
            üîç Review T·∫•t C·∫£ Chapters
        </button>
        <select id="volumeFilter" class="btn btn-secondary" onchange="filterReviewByVolume(this.value)">
            <option value="">T·∫•t c·∫£ Volumes</option>
            {% for volume in novel.volumes.all %}
            <option value="{{ volume.id }}">Volume {{ volume.index }}</option>
            {% endfor %}
        </select>
    </div>
    
    <div class="review-stats">
        <div class="review-card">
            <div class="stat-label">Trung b√¨nh</div>
            <div class="stat-value" id="avgScore">‚Äî</div>
        </div>
        <div class="review-card">
            <div class="stat-label">ƒê√£ review</div>
            <div class="stat-value" id="reviewedCount">0</div>
        </div>
        <div class="review-card">
            <div class="stat-label">C·∫ßn c·∫£i thi·ªán (&lt;80%)</div>
            <div class="stat-value" id="lowScoreCount">0</div>
        </div>
    </div>
    
    <div id="reviewResults"></div>
</div>

<!-- Loading Overlay -->
<div class="loading-overlay" id="loadingOverlay">
    <div class="loading-content">
        <div class="loading-spinner"></div>
        <div style="font-weight: 600; color: var(--dark); margin-bottom: 0.5rem;" id="loadingText">ƒêang x·ª≠ l√Ω...</div>
        <div style="color: var(--text-light); font-size: 0.9rem;" id="loadingSubtext"></div>
        <div class="progress-bar">
            <div class="progress-fill" id="loadingProgress" style="width: 0%"></div>
        </div>
    </div>
</div>

<script>
const novelId = {{ novel.id }};
let currentEditingCell = null;
let currentPage = 1;
let searchQuery = '';

// Calculate total chapters
document.addEventListener('DOMContentLoaded', function() {
    const volumes = {{ novel.volumes.all|length }};
    let totalChapters = 0;
    {% for volume in novel.volumes.all %}
    totalChapters += {{ volume.chapters.count }};
    {% endfor %}
    document.getElementById('totalChapters').textContent = totalChapters;
    
    // Load glossary on tab switch
    const glossaryTab = document.querySelector('.tab[onclick*="glossary"]');
    if (glossaryTab) {
        const originalOnclick = glossaryTab.onclick;
        glossaryTab.onclick = function(e) {
            originalOnclick.call(this, e);
            loadGlossary(1);
        };
    }
});

function getCookie(name) {
    let value = "; " + document.cookie;
    let parts = value.split("; " + name + "=");
    if (parts.length === 2) return parts.pop().split(";").shift();
}

// Tab switching
function switchTab(tab) {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    
    event.target.classList.add('active');
    document.getElementById(tab + '-tab').classList.add('active');
    
    if (tab === 'glossary') {
        loadGlossary(1);
    } else if (tab === 'review') {
        loadReviewData();
    }
}

// Glossary functions with AJAX pagination
async function loadGlossary(page = 1, search = '') {
    try {
        const response = await fetch(`/novel/${novelId}/glossary/list/?page=${page}&search=${encodeURIComponent(search)}`);
        const data = await response.json();
        
        if (data.ok) {
            renderGlossaryTable(data.terms);
            renderPagination(data.pagination);
            document.getElementById('glossaryTotal').textContent = data.total_count;
            currentPage = page;
            searchQuery = search;
        }
    } catch (error) {
        console.error('Error loading glossary:', error);
    }
}

function renderGlossaryTable(terms) {
    const tbody = document.getElementById('glossaryTableBody');
    
    if (!terms || terms.length === 0) {
        tbody.innerHTML = `
            <tr id="emptyGlossary">
                <td colspan="4" style="text-align: center; padding: 3rem; color: var(--text-light);">
                    ${searchQuery ? 'Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£' : 'Ch∆∞a c√≥ glossary. Nh·∫•n "T·∫°o T·ª± ƒê·ªông" ƒë·ªÉ b·∫Øt ƒë·∫ßu.'}
                </td>
            </tr>
        `;
        return;
    }
    
    tbody.innerHTML = terms.map(term => `
        <tr data-term-id="${term.id}" data-search="${term.term_cn.toLowerCase()} ${term.term_vi.toLowerCase()}">
            <td class="editable-cell" onclick="editCell(this, ${term.id}, 'term_cn')">${term.term_cn}</td>
            <td class="editable-cell" onclick="editCell(this, ${term.id}, 'term_vi')">${term.term_vi}</td>
            <td class="editable-cell" onclick="editCell(this, ${term.id}, 'note')">${term.note || '‚Äî'}</td>
            <td>
                <button onclick="deleteTerm(${term.id})" class="btn-delete" style="background: var(--danger); color: white; border: none; padding: 0.5rem 0.75rem; border-radius: 6px; cursor: pointer;">
                    üóëÔ∏è
                </button>
            </td>
        </tr>
    `).join('');
}

function renderPagination(pagination) {
    const container = document.getElementById('glossaryPagination');
    
    if (!pagination || pagination.total_pages <= 1) {
        container.innerHTML = '';
        return;
    }
    
    let html = '';
    
    // Previous button
    if (pagination.has_previous) {
        html += `<button onclick="loadGlossary(${pagination.current_page - 1}, searchQuery)" class="page-link">‚Üê Tr∆∞·ªõc</button>`;
    }
    
    // Page numbers
    for (let i = 1; i <= pagination.total_pages; i++) {
        if (i === 1 || i === pagination.total_pages || 
            (i >= pagination.current_page - 2 && i <= pagination.current_page + 2)) {
            const activeClass = i === pagination.current_page ? 'active' : '';
            html += `<button onclick="loadGlossary(${i}, searchQuery)" class="page-link ${activeClass}">${i}</button>`;
        } else if (i === pagination.current_page - 3 || i === pagination.current_page + 3) {
            html += `<span class="page-link" style="border: none; cursor: default;">...</span>`;
        }
    }
    
    // Next button
    if (pagination.has_next) {
        html += `<button onclick="loadGlossary(${pagination.current_page + 1}, searchQuery)" class="page-link">Sau ‚Üí</button>`;
    }
    
    container.innerHTML = html;
}

let searchTimeout;
function searchGlossary(query) {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
        loadGlossary(1, query);
    }, 500);
}

async function generateGlossary() {
    const btn = document.getElementById('generateGlossaryBtn');
    if (!confirm('T·∫°o glossary t·ª± ƒë·ªông t·ª´ chapters? Qu√° tr√¨nh n√†y c√≥ th·ªÉ m·∫•t v√†i ph√∫t.')) {
        return;
    }
    
    showLoading('ƒêang t·∫°o glossary...', 'Vui l√≤ng ch·ªù...');
    
    try {
        const response = await fetch(`/novel/${novelId}/glossary/generate/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken'),
            },
            body: new URLSearchParams({ 'from_checkpoint': 'true' })
        });
        
        const data = await response.json();
        
        if (data.ok) {
            const summary = data.summary;
            alert(`‚úÖ Ho√†n t·∫•t!\n\n` +
                  `üìä ƒê√£ x·ª≠ l√Ω: ${summary.processed_chapters} chapters\n` +
                  `‚ûï Terms m·ªõi: ${summary.new_terms}\n` +
                  `üìñ T·ªïng terms: ${summary.total_terms}\n` +
                  `üìç Checkpoint: ${summary.checkpoint}`);
            loadGlossary(1);
            document.getElementById('glossaryCheckpoint').textContent = summary.checkpoint;
        } else {
            alert('L·ªói: ' + data.error);
        }
    } catch (error) {
        alert('L·ªói k·∫øt n·ªëi: ' + error);
    } finally {
        hideLoading();
    }
}

function editCell(cell, termId, field) {
    if (currentEditingCell) {
        currentEditingCell.isEditing = false;
    }
    
    const currentValue = cell.textContent.trim();
    if (currentValue === '‚Äî') {
        cell.textContent = '';
    }
    
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'edit-input';
    input.value = cell.textContent.trim();
    
    input.onblur = () => saveCell(cell, termId, field, input.value);
    input.onkeydown = (e) => {
        if (e.key === 'Enter') {
            saveCell(cell, termId, field, input.value);
        } else if (e.key === 'Escape') {
            cell.textContent = currentValue || '‚Äî';
        }
    };
    
    cell.textContent = '';
    cell.appendChild(input);
    input.focus();
    input.select();
    
    currentEditingCell = cell;
    currentEditingCell.isEditing = true;
}

async function saveCell(cell, termId, field, value) {
    if (!currentEditingCell || !currentEditingCell.isEditing) return;
    
    try {
        const response = await fetch(`/novel/${novelId}/glossary/update/${termId}/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken'),
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ field, value })
        });
        
        if (response.ok) {
            cell.textContent = value || '‚Äî';
        } else {
            alert('L·ªói khi l∆∞u');
        }
    } catch (error) {
        alert('L·ªói: ' + error);
    }
    
    currentEditingCell = null;
}

async function deleteTerm(termId) {
    if (!confirm('X√≥a term n√†y?')) return;
    
    try {
        const response = await fetch(`/glossary/${termId}/delete/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': getCookie('csrftoken') }
        });
        
        if (response.ok) {
            loadGlossary(currentPage, searchQuery);
        }
    } catch (error) {
        alert('L·ªói: ' + error);
    }
}

async function resetCheckpoint() {
    if (!confirm('Reset checkpoint v·ªÅ 0? L·∫ßn t·∫°o glossary ti·∫øp theo s·∫Ω x·ª≠ l√Ω t·ª´ ƒë·∫ßu.')) return;
    
    try {
        const response = await fetch(`/novel/${novelId}/glossary/reset/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': getCookie('csrftoken') }
        });
        
        if (response.ok) {
            document.getElementById('glossaryCheckpoint').textContent = '0';
            alert('‚úÖ ƒê√£ reset checkpoint!');
        }
    } catch (error) {
        alert('L·ªói: ' + error);
    }
}

// Review functions
async function loadReviewData() {
    try {
        const response = await fetch(`/novel/${novelId}/review/stats/`);
        const data = await response.json();
        
        if (data.ok) {
            document.getElementById('avgScore').textContent = data.avg_score + '%';
            document.getElementById('reviewedCount').textContent = data.reviewed_count;
            document.getElementById('lowScoreCount').textContent = data.low_score_count;
            
            renderReviewResults(data.chapters);
        }
    } catch (error) {
        console.error('Error loading review data:', error);
    }
}

function renderReviewResults(chapters) {
    const container = document.getElementById('reviewResults');
    if (!chapters || chapters.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 3rem; color: var(--text-light);">Ch∆∞a c√≥ chapter n√†o ƒë∆∞·ª£c review.</div>';
        return;
    }
    
    container.innerHTML = chapters.map(ch => {
        const scoreClass = ch.match_percent >= 80 ? 'score-high' : ch.match_percent >= 60 ? 'score-medium' : 'score-low';
        return `
            <div class="chapter-review-item" data-volume="${ch.volume_id}">
                <div class="review-header">
                    <div>
                        <strong style="font-size: 1.1rem;">${ch.title}</strong>
                        <div style="color: var(--text-light); font-size: 0.9rem; margin-top: 0.25rem;">
                            Volume ${ch.volume_index} - Chapter ${ch.chapter_index}
                        </div>
                    </div>
                    <span class="score-badge ${scoreClass}">${ch.match_percent.toFixed(1)}%</span>
                </div>
                ${ch.review ? `<div style="color: var(--text); line-height: 1.6; white-space: pre-line;">${ch.review}</div>` : ''}
            </div>
        `;
    }).join('');
}

async function reviewAllChapters() {
    if (!confirm('Review t·∫•t c·∫£ chapters? Qu√° tr√¨nh n√†y c√≥ th·ªÉ m·∫•t nhi·ªÅu ph√∫t.')) return;
    
    showLoading('ƒêang review chapters...', 'ƒê√£ x·ª≠ l√Ω: 0 chapters');
    
    try {
        const response = await fetch(`/novel/${novelId}/review/all/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': getCookie('csrftoken') }
        });
        
        const data = await response.json();
        
        if (data.ok) {
            alert(`‚úÖ Ho√†n t·∫•t!\n\nƒê√£ review: ${data.reviewed_count} chapters\nƒêi·ªÉm TB: ${data.avg_score}%`);
            loadReviewData();
        } else {
            alert('L·ªói: ' + data.error);
        }
    } catch (error) {
        alert('L·ªói: ' + error);
    } finally {
        hideLoading();
    }
}

function filterReviewByVolume(volumeId) {
    const items = document.querySelectorAll('.chapter-review-item');
    items.forEach(item => {
        if (!volumeId || item.dataset.volume === volumeId) {
            item.style.display = '';
        } else {
            item.style.display = 'none';
        }
    });
}

function showLoading(text, subtext) {
    document.getElementById('loadingText').textContent = text;
    document.getElementById('loadingSubtext').textContent = subtext || '';
    document.getElementById('loadingOverlay').classList.add('show');
}

function hideLoading() {
    document.getElementById('loadingOverlay').classList.remove('show');
}

function showAddGlossaryModal() {
    const termCn = prompt('Ti·∫øng Trung:');
    if (!termCn) return;
    
    const termVi = prompt('Ti·∫øng Vi·ªát:');
    if (!termVi) return;
    
    const note = prompt('Ghi ch√∫ (t√πy ch·ªçn):');
    
    addGlossaryTerm(termCn, termVi, note || '');
}

async function addGlossaryTerm(termCn, termVi, note) {
    try {
        const response = await fetch(`/novel/${novelId}/glossary/add/`, {
            method: 'POST',
            headers: { 
                'X-CSRFToken': getCookie('csrftoken'),
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({ term_cn: termCn, term_vi: termVi, note: note })
        });
        
        if (response.ok) {
            loadGlossary(currentPage, searchQuery);
            const total = parseInt(document.getElementById('glossaryTotal').textContent);
            document.getElementById('glossaryTotal').textContent = total + 1;
        } else {
            alert('L·ªói khi th√™m term');
        }
    } catch (error) {
        alert('L·ªói: ' + error);
    }
}

</script>
{% endblock %}

// Calculate total chapters
document.addEventListener('DOMContentLoaded', function() {
    const volumes = {{ novel.volumes.all|length }};
    let totalChapters = 0;
    {% for volume in novel.volumes.all %}
    totalChapters += {{ volume.chapters.count }};
    {% endfor %}
    document.getElementById('totalChapters').textContent = totalChapters;
    
    // Load review data on page load
    if (document.getElementById('review-tab').classList.contains('active')) {
        loadReviewData();
    }
});

function getCookie(name) {
    let value = "; " + document.cookie;
    let parts = value.split("; " + name + "=");
    if (parts.length === 2) return parts.pop().split(";").shift();
}

// Tab switching
function switchTab(tab) {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    
    event.target.classList.add('active');
    document.getElementById(tab + '-tab').classList.add('active');
    
    if (tab === 'review') {
        loadReviewData();
    }
}

// Glossary functions
async function generateGlossary() {
    const btn = document.getElementById('generateGlossaryBtn');
    if (!confirm('T·∫°o glossary t·ª± ƒë·ªông t·ª´ chapters? Qu√° tr√¨nh n√†y c√≥ th·ªÉ m·∫•t v√†i ph√∫t.')) {
        return;
    }
    
    showLoading('ƒêang t·∫°o glossary...', 'Vui l√≤ng ch·ªù...');
    
    try {
        const response = await fetch(`/novel/${novelId}/glossary/generate/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken'),
            },
            body: new URLSearchParams({ 'from_checkpoint': 'true' })
        });
        
        const data = await response.json();
        
        if (data.ok) {
            const summary = data.summary;
            alert(`‚úÖ Ho√†n t·∫•t!\n\n` +
                  `üìä ƒê√£ x·ª≠ l√Ω: ${summary.processed_chapters} chapters\n` +
                  `‚ûï Terms m·ªõi: ${summary.new_terms}\n` +
                  `üìñ T·ªïng terms: ${summary.total_terms}\n` +
                  `üìç Checkpoint: ${summary.checkpoint}`);
            location.reload();
        } else {
            alert('L·ªói: ' + data.error);
        }
    } catch (error) {
        alert('L·ªói k·∫øt n·ªëi: ' + error);
    } finally {
        hideLoading();
    }
}

function searchGlossary(query) {
    const rows = document.querySelectorAll('#glossaryTableBody tr[data-term-id]');
    const lowerQuery = query.toLowerCase();
    
    rows.forEach(row => {
        const searchText = row.getAttribute('data-search');
        if (searchText && searchText.includes(lowerQuery)) {
            row.style.display = '';
        } else {
            row.style.display = 'none';
        }
    });
}

function editCell(cell, termId, field) {
    if (currentEditingCell) {
        currentEditingCell.isEditing = false;
    }
    
    const currentValue = cell.textContent.trim();
    if (currentValue === '‚Äî') {
        cell.textContent = '';
    }
    
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'edit-input';
    input.value = cell.textContent.trim();
    
    input.onblur = () => saveCell(cell, termId, field, input.value);
    input.onkeydown = (e) => {
        if (e.key === 'Enter') {
            saveCell(cell, termId, field, input.value);
        } else if (e.key === 'Escape') {
            cell.textContent = currentValue || '‚Äî';
        }
    };
    
    cell.textContent = '';
    cell.appendChild(input);
    input.focus();
    input.select();
    
    currentEditingCell = cell;
    currentEditingCell.isEditing = true;
}

async function saveCell(cell, termId, field, value) {
    if (!currentEditingCell || !currentEditingCell.isEditing) return;
    
    try {
        const response = await fetch(`/novel/${novelId}/glossary/update/${termId}/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken'),
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ field, value })
        });
        
        if (response.ok) {
            cell.textContent = value || '‚Äî';
        } else {
            alert('L·ªói khi l∆∞u');
        }
    } catch (error) {
        alert('L·ªói: ' + error);
    }
    
    currentEditingCell = null;
}

async function deleteTerm(termId) {
    if (!confirm('X√≥a term n√†y?')) return;
    
    try {
        const response = await fetch(`/glossary/${termId}/delete/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': getCookie('csrftoken') }
        });
        
        if (response.ok) {
            document.querySelector(`tr[data-term-id="${termId}"]`).remove();
            const count = document.querySelectorAll('#glossaryTableBody tr[data-term-id]').length;
            document.getElementById('glossaryTotal').textContent = count;
            
            if (count === 0) {
                document.getElementById('glossaryTableBody').innerHTML = '<tr id="emptyGlossary"><td colspan="4" style="text-align: center; padding: 3rem; color: var(--text-light);">Ch∆∞a c√≥ glossary.</td></tr>';
            }
        }
    } catch (error) {
        alert('L·ªói: ' + error);
    }
}

async function resetCheckpoint() {
    if (!confirm('Reset checkpoint v·ªÅ 0? L·∫ßn t·∫°o glossary ti·∫øp theo s·∫Ω x·ª≠ l√Ω t·ª´ ƒë·∫ßu.')) return;
    
    try {
        const response = await fetch(`/novel/${novelId}/glossary/reset/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': getCookie('csrftoken') }
        });
        
        if (response.ok) {
            document.getElementById('glossaryCheckpoint').textContent = '0';
            alert('‚úÖ ƒê√£ reset checkpoint!');
        }
    } catch (error) {
        alert('L·ªói: ' + error);
    }
}

// Review functions
async function loadReviewData() {
    try {
        const response = await fetch(`/novel/${novelId}/review/stats/`);
        const data = await response.json();
        
        if (data.ok) {
            document.getElementById('avgScore').textContent = data.avg_score + '%';
            document.getElementById('reviewedCount').textContent = data.reviewed_count;
            document.getElementById('lowScoreCount').textContent = data.low_score_count;
            
            renderReviewResults(data.chapters);
        }
    } catch (error) {
        console.error('Error loading review data:', error);
    }
}

function renderReviewResults(chapters) {
    const container = document.getElementById('reviewResults');
    if (!chapters || chapters.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 3rem; color: var(--text-light);">Ch∆∞a c√≥ chapter n√†o ƒë∆∞·ª£c review.</div>';
        return;
    }
    
    container.innerHTML = chapters.map(ch => {
        const scoreClass = ch.match_percent >= 80 ? 'score-high' : ch.match_percent >= 60 ? 'score-medium' : 'score-low';
        return `
            <div class="chapter-review-item" data-volume="${ch.volume_id}">
                <div class="review-header">
                    <div>
                        <strong style="font-size: 1.1rem;">${ch.title}</strong>
                        <div style="color: var(--text-light); font-size: 0.9rem; margin-top: 0.25rem;">
                            Volume ${ch.volume_index} - Chapter ${ch.chapter_index}
                        </div>
                    </div>
                    <span class="score-badge ${scoreClass}">${ch.match_percent.toFixed(1)}%</span>
                </div>
                ${ch.review ? `<div style="color: var(--text); line-height: 1.6; white-space: pre-line;">${ch.review}</div>` : ''}
            </div>
        `;
    }).join('');
}

async function reviewAllChapters() {
    if (!confirm('Review t·∫•t c·∫£ chapters? Qu√° tr√¨nh n√†y c√≥ th·ªÉ m·∫•t nhi·ªÅu ph√∫t.')) return;
    
    showLoading('ƒêang review chapters...', 'ƒê√£ x·ª≠ l√Ω: 0 chapters');
    
    try {
        const response = await fetch(`/novel/${novelId}/review/all/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': getCookie('csrftoken') }
        });
        
        const data = await response.json();
        
        if (data.ok) {
            alert(`‚úÖ Ho√†n t·∫•t!\n\nƒê√£ review: ${data.reviewed_count} chapters\nƒêi·ªÉm TB: ${data.avg_score}%`);
            loadReviewData();
        } else {
            alert('L·ªói: ' + data.error);
        }
    } catch (error) {
        alert('L·ªói: ' + error);
    } finally {
        hideLoading();
    }
}

function filterReviewByVolume(volumeId) {
    const items = document.querySelectorAll('.chapter-review-item');
    items.forEach(item => {
        if (!volumeId || item.dataset.volume === volumeId) {
            item.style.display = '';
        } else {
            item.style.display = 'none';
        }
    });
}

function showLoading(text, subtext) {
    document.getElementById('loadingText').textContent = text;
    document.getElementById('loadingSubtext').textContent = subtext || '';
    document.getElementById('loadingOverlay').classList.add('show');
}

function hideLoading() {
    document.getElementById('loadingOverlay').classList.remove('show');
}

function showAddGlossaryModal() {
    const termCn = prompt('Ti·∫øng Trung:');
    if (!termCn) return;
    
    const termVi = prompt('Ti·∫øng Vi·ªát:');
    if (!termVi) return;
    
    const note = prompt('Ghi ch√∫ (t√πy ch·ªçn):');
    
    addGlossaryTerm(termCn, termVi, note || '');
}

async function addGlossaryTerm(termCn, termVi, note) {
    try {
        const response = await fetch(`/novel/${novelId}/glossary/add/`, {
            method: 'POST',
            headers: { 
                'X-CSRFToken': getCookie('csrftoken'),
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({ term_cn: termCn, term_vi: termVi, note: note })
        });
        
        if (response.ok) {
            location.reload();
        } else {
            alert('L·ªói khi th√™m term');
        }
    } catch (error) {
        alert('L·ªói: ' + error);
    }
}
</script>